/**
 * Un thinker de base pour toute les créatures avec une IA
 */
var O2 = require('o2');
var MoverThinker = require('./MoverThinker.js');
var u = require('mwgame/Utils.js');
var Bresenham = require('mwgame/Bresenham.js');
var CONST = require('mwgame/data/consts.js');

var CreatureThinker = O2.extendClass(MoverThinker, {
	
	_nActionTime: 0,   // durée de l'action avant de passer à la suivante
	_oTarget: null,
	MAX_INVISIBLE_DISTANCE: 384,
	MAX_VISIBLE_DISTANCE: 640, 
	
	boundTestWalkable: null,
	
	__construct: function() {
		this.boundTestWalkable = this.testWalkable.bind(this);
		O2.parent(this);		
		this.setThink('Init');
	},
	

	////// METHODS ////// METHODS ////// METHODS ////// METHODS //////
	////// METHODS ////// METHODS ////// METHODS ////// METHODS //////
	////// METHODS ////// METHODS ////// METHODS ////// METHODS //////
	/**
	 * Set the action time
	 */
	setActionTime: function(t) {
		this._nActionTime = t;
	},	

	
	////// TESTS ////// TESTS ////// TESTS ////// TESTS ////// TESTS //////
	////// TESTS ////// TESTS ////// TESTS ////// TESTS ////// TESTS //////
	////// TESTS ////// TESTS ////// TESTS ////// TESTS ////// TESTS //////
	
	/**
	 * Returns true if the time has expired
	 */
	testActionTimeOut: function() {
		return --this._nActionTime <= 0;
	},

	/**
	 * Returns true if there is a visible enemy
	 * Select this enemy as primary target
	 */
	testHostileVisible: function() {
		var oTarget = this.getTarget();
		if (oTarget && this.isEntityVisible(oTarget)) {
			return true;
		} else {
			this.setTarget(this.getNearestVisibleHostileEntity());
		}
		return !!oTarget;
	},






	// Example : init -> branching on another thinker
	thinkInit: function() {
	},

	// death thinker
	thinkDead_enter: function() {
		this.oEntity.setData('summoner', null);
		this.oEntity.bActive = false;
	},

	thinkDead: function() {
	},
	
	thinkHold: function() {
	},

	

	actionHold: function() {
		var oCreature = this.oEntity.getSoul();
		if (oCreature.getAttribute('hold') > 0) {
			this.setThink('hold');
		} else {
			this.setThink('init');
		}
	},
	
	actionAim: function() {
		var oEntity = this.oEntity;
		var a;
		var oTarget = this.getTarget();
		if (oTarget && this.isEntityVisible(oTarget)) {
			a = this.getEntityAngle(oTarget);
			oEntity.setCourse(a);
			this.oGame.pushNetworkMessage(this.oGame.getClientEntities(), {m: 'ani', i: oEntity.getId(), a: 2});
		}
	},
	
	
	/**
	 * Attack
	 */
	actionAttack: function() {
		var oEntity = this.oEntity;
		var oTarget = this.getTarget();
		if (oTarget) {
			a = this.getEntityAngle(oTarget);
			oEntity.setCourse(a);
			this.oGame.entityAttack(oEntity, 0);
		}
	},
	
	/**
	 * Stop walking
	 */
	actionStop: function() {
		this.oEntity.setSpeedVector(this.oEntity.a, 0);
	},
	
	
	
	
	
	/**
	 * Renvoie l'angle q'uil faut adopter pour viser la cible
	 */
	getEntityAngle: function(oTarget) {
		var oMe = this.oEntity;
		var fTheta = oMe.a;
		oTarget = oTarget || this.getTarget();
		if (oTarget !== null) {
			fTheta = Math.atan2(oTarget.y - oMe.y, oTarget.x - oMe.x);
			if (!this.isEntityVisible(oTarget)) { // cible invisible ou mobile aveuglé
				if (this.distanceTo(oTarget) >= this.MAX_INVISIBLE_DISTANCE) {
					return false;
				}
				fTheta += 6 * u.rand() - 3;
			}
			return fTheta;
		}
		return false;	
	},
	
	/**
	 * Renvoie true si le sujet peut voir la cible.
	 * pour que la fonction renvoie true il faut que le sujet puisse voir la cible
	 * ceci prend en compte l'invisibilité de la cible, 
	 * le niveau de detection et l'aveuglement du sujet,
	 * les obstacle muraux qui cacheraient éventuellement la cible
	 * @return bool
	 */
	isEntityVisible : function(oTarget) {
		if (oTarget === null) {
			return false;
		}
		var oMe = this.oEntity;
		var oTargetCreature = oTarget.getSoul();
		var oCreature = oMe.getSoul();
		if (!oCreature) {
			return false;
		}

		var bInvisible = oTargetCreature.getAttribute('invisible') > 0;
		var bEsp = oCreature.getAttribute('esp') > 0;
		var bBlind = oCreature.getAttribute('blind') > 0;
		
		var nMask = (bInvisible ? 4 : 0) | (bEsp ? 2 : 0) | (bBlind ? 1 : 0);
		
		switch (nMask) {
			case 0: // all normal 
			case 2: // esp
			case 6: // esp and target invisible
				var xTarget = oTarget.xSector;
				var yTarget = oTarget.ySector;
				var xMe = oMe.xSector;
				var yMe = oMe.ySector;
				return !Bresenham.line(xMe, yMe, xTarget, yTarget, this.boundTestWalkable);
				
			default:
				return false;
		}
	},

	testWalkable: function(x, y) {
		return !this.oGame.isWalkable(x, y);
	},

	/**
	 * Renvoie la cible prédédemment sélectionnée avec
	 * vérification de sa vie si la cible est détruite, renvoie
	 * null
	 */
	getTarget : function() {
		if (this._oTarget && (this._oTarget.bActive === false || this._oTarget.getSoul().getAttribute('dead') > 0)) {
			this._oTarget = null;
		}
		return this._oTarget;
	},
	
	/**
	 * Définit la nouvelle cible à abattre
	 * @param oTarget Entity
	 */
	setTarget: function(oTarget) {
		this._oTarget = oTarget;
	},
	
	/**
	 * Renvoie true si la cible est hostile
	 * @param oTarget
	 * @returns bool
	 */
	isEntityHostile: function(oTarget) {
		var oMe = this.oEntity;
		var oCreature = oMe.getSoul();
		var bConfused = oCreature.getAttribute('confused') > 0;
		var oMaster = oMe.getData('charmer') || oMe.getData('summoner'); 
		if (oMaster == oTarget) {
			return bConfused;
		}
		var nMyFaction = oMe.getData('faction');
		if (nMyFaction) {
			return bConfused || (nMyFaction !== oTarget.getData('faction'));
		} else {
			return true;
		}
	},
	
	/**
	 * Return true if the entity is old enought
	 * Freshly connected player should not be attacked
	 * This is not fair play
	 * @param oTarget Tested Entity
	 * @return bool 
	 */
	isEntityOldEnough: function(oTarget) {
		if (oTarget.getType() === CONST.ENTITY_TYPE_PLAYER) {
			var nCreationTime = oTarget.getData('creationTime') | 0;
			return this.oGame.getTime() - nCreationTime > 4;
		} else {
			return true;
		}
	},


	/**
	 * Renvoie la distance séparant le mob de sa cible si la
	 * cible est détruite, la distance renvoyé est -1
	 * @param oTarget Entity 
	 * @return float
	 */
	distanceTo: function(oTarget) {
		if (oTarget) {
			var oEntity = this.oEntity;
			return u.distance(oEntity.x, oEntity.y, oTarget.x, oTarget.y);
		} else {
			return -1;
		}
	},
	
	/**
	 * Recherche la cible la plus proche.
	 * - critère de distance
	 * - critère de faction
	 * - critère d'angle
	 */
	getNearestVisibleHostileEntity: function() {
		var i, oMob, oMe = this.oEntity;
		var nMaxDistance = this.MAX_VISIBLE_DISTANCE;
		var h = this.oGame.getAreaEntities([CONST.ENTITY_TYPE_PLAYER, CONST.ENTITY_TYPE_MOB], oMe.x, oMe.y, nMaxDistance);
		var n = h.length;
		for (i = 0; i < n; ++i) {
			oMob = h[i];
			if (oMob == oMe) {
				continue;
			}
			// check faction, visibility, distance
			if (oMob) {
				if (this.isEntityOldEnough(oMob) && 
					this.isEntityHostile(oMob) && 
					this.isEntityVisible(oMob) && 
					this.distanceTo(oMob) < nMaxDistance					
				) {
					return oMob;
				}
			}
		}
		// no mob
		return null;
	},

});

module.exports = CreatureThinker;
